import os
import sys
import json
import logging
import contextvars
from typing import Optional

import colorlog
import google.cloud.logging
from google.cloud.logging_v2.handlers import CloudLoggingHandler

import utils

# ============================================================
# ===============   Logging   ==============
# ============================================================
trace_id_var = contextvars.ContextVar("trace_id", default="no-trace")

def set_trace_id(trace_id: str):
    trace_id_var.set(trace_id)

class ContextFilter(logging.Filter):
    def filter(self, record):
        record.trace_id = trace_id_var.get()
        return True

logger = logging.getLogger(__file__)
logger.setLevel(logging.INFO)

# Local Logging
stdout = colorlog.StreamHandler(stream=sys.stdout)
stdout.addFilter(ContextFilter())
fmt = colorlog.ColoredFormatter(
    "%(name)s: %(white)s%(asctime)s%(reset)s | "
    "%(log_color)s%(levelname)s%(reset)s | "
    "%(blue)s%(filename)s:%(lineno)s%(reset)s | "
    "%(cyan)s%(trace_id)s%(reset)s | "
    "%(process)d >>> %(log_color)s%(message)s%(reset)s"
)
stdout.setFormatter(fmt)
logger.addHandler(stdout)

#Google Cloud Logging
class JsonFormatter(logging.Formatter):
    """Custom formatter that outputs logs as JSON."""
    def format(self, record):
        log_record = {
            "timestamp": self.formatTime(record, "%Y-%m-%dT%H:%M:%SZ"),
            "severity": record.levelname,
            "message": record.getMessage(),
            "logger": record.name,
            "filename": record.filename,
            "line": record.lineno,
            "process": record.process,
            "trace_id": getattr(record, "trace_id", "no-trace")
        }
        if record.exc_info:
            log_record["exception"] = self.formatException(record.exc_info)
        return json.dumps(log_record)

client = google.cloud.logging.Client()
cloud_handler = CloudLoggingHandler(client)
cloud_handler.addFilter(ContextFilter())
cloud_handler.setFormatter(JsonFormatter())
logger.addHandler(cloud_handler)


# ============================================================
# ===============   Vars and Constants   ==============
# ============================================================
blob_name = os.getenv('blob_name')
bucket_name = os.getenv('bucket_name', 'segment_hunter__dev')

if not (blob_name and bucket_name):
    raise EnvironmentError("Environment variables unset")


# ============================================================
# ===============   Functions   ==============
# ============================================================

def convert_json_to_ndjson(data: dict) -> Optional[str]:
    """Converts JSON object with a list of items into NDJSON string

    Args:
        data (dict): JSON object serialised as a dict

    Returns:
        Optional[str]: NDJSON string, or None if no segments
    """
    segments = data.get("segments",[])
    if not segments:
        logger.warning(
            f"No segments found - skipping"
        )
        return None
    time_fetched = data.get("time_fetched")

    ndjson_lines = []
    for seg in segments:
        seg_with_meta = seg.copy()
        if time_fetched is not None:
            seg_with_meta["time_fetched"] = time_fetched
        ndjson_lines.append(
            json.dumps(seg_with_meta, separators=(",",":")))
    
    ndjson = "\n".join(ndjson_lines)
    logger.info(f"{len(segments)} segments converted to NDJSON")
    return ndjson

# ============================================================
# ===============   Main Logic  ==============
# ============================================================
def main():
    set_trace_id(blob_name)
    json_blob = utils.download_json_blob(bucket_name, blob_name)
    nd_json = convert_json_to_ndjson(json_blob)
    if nd_json is not None:
        utils.upload_blob_from_string(bucket_name, nd_json, "explored_segments_ndjson/"+blob_name)

def safe_main():
    try:
        main()
    except Exception as e:
        logger.exception(f"Unhandled error: {e}")
        raise

if __name__ == "__main__":
    safe_main()